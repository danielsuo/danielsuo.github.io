<!doctype html>
<html>
  
  <head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Daniel Suo | Scientific progress goes 'boink'</title>

<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/pygment_trac.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/assets/img/profile.jpg" />

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
</head>

  <body id='Secure Names for Bit-Strings'>
    
    <div class='wrapper'>
      
      <header>
    <h1>Daniel Suo</h1>
    <p>Scientific progress goes 'boink'</p>

    <p>
      Ph.D. Candidate<br>
      Princeton University<br>
      Department of Computer Science
    </p>
    
<!--     <ul>
    	<li><a href="/">home</a></li>
      <li><a href="/projects">projects</a></li>
      <li><a href="/notes">notes</a></li>
    </ul>
     -->
</header>

      <section>

        <div id='container'>
          <h2 id="secure-names-for-bit-strings">Secure Names for Bit-Strings</h2>
<p>Stuart Haber and W. Scott Stornetta (<a href="secure-names-bit-strings.pdf">original</a>)</p>

<h3 id="abstract">Abstract</h3>
<p>The increasing use of digital documents, and the need to refer to them conveniently and unambiguously, raise an important question: can one “name” a digital document in a way that conveniently enables users to find it, and at the same time enables a user in possession of a document to be sure that it is indeed the one that is referred to by the name? One crucial piece of a complete solution to this problem would be a method that provides a cryptographically verifiable label for any bit-string (for example, the content, in a particular format, of the document). This problem has become even more acute with the emergence of the World-Wide Web, where a document (whose only existence may be on-line) is now typically named by giving its URL, which is merely a pointer to its virtual location at a particular moment in time.</p>

<p>Using a one-way hash function to call files by their hash values is cryptographically verifiable, but the resulting names are unwieldy, because of their length and randomness, and are not permanent, since as time goes on the hash function may become vulnerable to attack. We introduce procedures to create names that are short and meaningful, while at the same time they can persist indefinitely, independent of the longevity of any given hash function. This is done by naming a bit-string according to its position in a growing, directed acyclic graph of one-way hash values. We prove the security of our naming procedures under a reasonable complexity-theoretic cryptographic assumption, and then describe practical uses for these names. An implementation of our naming scheme has been in use since January 1995.</p>

<h3 id="introduction">1. Introduction</h3>
<p>Users of documents need to refer to those documents in order to keep records and in order to communicate with other users of the documents. In practice, users name their documents in various ways. A name must be unambiguous, at least in the context of its use; this requires some connection between the name and the integrity of the document it names.</p>

<p>In the traditional world of paper documents, there are usually reasonable guarantees of this connection. In the case of printed books and magazines, large print runs that are the result of single typesetting efforts make it easier to be confident that all copies of a printed document are the same with a definite name printed in a conventional place in the document. Making a change to a paper document of any sort, even a small change, typically leaves forensic evidence.</p>

<p>A characteristic feature of digital documents, by contrast, is that they are easy to copy and to alter. The naming problem is especially troubling if the document exists only on-line and never in conventional paper-based form. For on-line documents, a useful naming scheme would allow users to employ the name to <em>find</em> documents, as well as to check the <em>integrity</em> of the documents that they find. A number of proposals have been made for such naming systems (see e.g. [SM 94, KW 95, BD+ 95]). These proposals address in different ways the problem of how to “resolve” the name into a location where the document might be found.</p>

<p>It is the integrity-checking problem that we address in this work: how to make sure that the bit-string content of a given digital document is indeed the same as the bit-string that was intended. Heretofore, two different sorts of mechanisms have been proposed, digital signatures and one-way hash values.</p>

<p>Having the author or publisher of a document compute a digital signature for its bit-string content is a reasonable use of cryptographic tools for this purpose. (See, for example, [R 95, M 94].) However, the ability to validate many digital signatures requires the presence of a public-key infrastructure, and the trustworthiness of the validation procedure relies on the assurance that the signer’s private signing key is indeed secure. For some on-line documents, the infrastructure and these assurances may not be available. For long-lived documents, the security of the binding between a public key and the person or role of the putative signer becomes even more problematic. (A general solution to the latter problem is briefly described in §5.)</p>

<p>Thus it would be useful to have an integrity mechanism, depending on the exact contents of the bit-string in question, that does not depend on the secrecy of a cryptographic key. A natural choice for such a mechanism is the use of a one-way hash function, naming any bit-string by its hash value. (See, for example, [BD+ 95].) However, while this method is intrinsicially verifiable, there are several inconvenient features:</p>

<p>A desirable feature for the names given to a collection of objects is that they be long-lasting, if not permanent. (This is one of the functional requirements for URNs [SM 94].) But as technology advances, any particular choice of a presumably one-way function for a naming scheme becomes less secure, so that it must be replaced (see [Dob 96a, Dob 96b]). The unpleasant result is that the name of a long-lived document will need to change over time.
Hash values are too long for a human user to remember or even to communicate easily to another human being. (For example, it is currently recommended that one-way hash functions compute outputs that are at the very least 128 bits long; this is the output length of MD5 [Riv 92]. In a 6 bit/character encoding, this is 22 alphanumeric characters long.)
The author of a bit-string document has no control over the form of its name. A one-way hash function produces a random-appearing bit-string of the appropriate length as the hash value of a document. Thus, inconvenient as it may be for the author, there will be no connection between the names of documents that are related to each other, either in form or in substance.</p>

<p>This paper presents a method for naming bit-strings that retains the verifiable security of hash-based names, while avoiding the constraints listed above, as well as avoiding the use of secret cryptographic keys. The method is a variation on the digital time-stamping schemes of [HS 91, BHS 93]. In summary, the essence of the new scheme is to keep a repository of hash values that depends on many bit-string inputs, and to name each bit-string by a concise description of a location in the repository to which it can be securely “linked” by a one-way hashing computation.</p>

<p>An implementation of our naming scheme has been running continuously since January 1995 [Sur 95].</p>

<p>The rest of this paper is organized as follows. After technical preliminaries in §2, including both a brief discussion of the wider problem of naming digital documents as well as a formal description of our sub-problem, we present our scheme and prove its security in §3. Motivated by the explosive growth of the Internet, we mention a number of possible applications of our scheme in §4. In §5, we describe a method for extending the lifetime of our digital names beyond the cryptographically secure lifetime of the hash functions used to compute them. Finally, we discuss several different sorts of practical implementation in §6.</p>

<h3 id="preliminaries">2. Preliminaries</h3>

<h4 id="naming-digital-documents">2.1 Naming digital documents</h4>
<p>A naming system for digital documents should perform (at least) two functions. It should help the user (1) to find the document named; and (2) to reassure himself or herself that a given document is indeed the correct one, i.e., that it is indeed a perfect copy of the document that was intended.</p>

<p>To enable both these functions, the “name” could include both identification information as well as location information. System design may include procedures for registration of new documents, for finding a document given its name, for updating a document’s location information, and for validating the integrity of a document. Typically, there is a server that “resolves” or translates a name into location information, for example into a URL or a list of URLs. The name may include other information about the document, including such data as title, author, format, price, and access priveleges.</p>

<p>A large body of work has been devoted to the difficult problem of designing and building a naming system of this sort so that it is usable, useful, and reliable. In [SM 94] a set of functional requirements is described for Uniform Resource Names (URNs), the names to be assigned by a naming system for resources on the Internet. A number of researchers have built naming systems, including, among others, [KW 95, BD+ 95]. (This is by no means an exhaustive list.)</p>

<p>In this work we propose a new method for the integrity-checking piece of naming systems for digital documents. All previously proposed systems that included mechanisms for checking the integrity of the bit-strings or bit-strings that make up a digital document have used either digital signatures or one-way hash functions for this purpose. For certain applications, these methods have the same problems described in §1 above.</p>

<h4 id="hash-functions">2.2 Hash functions</h4>
<p>The principal technical tool we use in this paper is that of a one-way hash function. This is a function compressing digital documents of arbitrary length to bit-strings of a fixed length, for which it is computationally infeasible to find two different documents that are mapped by the function to the same <em>hash value</em>. (Such a pair is called a collision for the hash function.)</p>

<p>Practical proposals for one-way hash functions include those of MD5 [Riv 92], SHA-1 [NIST 94], and RIPEMD-160 [DBP 96]. Though the actual security of these functions (i.e., the precise difficulty of computing collisons for them) is not known, they are now in more or less widespread use.</p>

<p><strong>Definition</strong> In a more theoretical veign, Damgård defined a family of <em>collision-free hash functions</em> to be a family <script type="math/tex">\{H_k\}_k</script> of sets of functions (indexed by a security parameter <script type="math/tex">k</script>) with the following properties:</p>

<ol>
  <li>Each <script type="math/tex">H_k</script> is a set of functions <script type="math/tex">h:\{0,1\}^* \rightarrow \{0,1\}^k</script> that are computable in polynomial time.</li>
  <li>Given <script type="math/tex">k</script>, it is easy to choose $h\in H_k$ at random.</li>
  <li>It is computationally infeasible, given a random choice of one of these functions, to find a collision for the function. More precisely, for any polynomial algorithm <script type="math/tex">A</script>, for an positive constant <script type="math/tex">c</script>,</li>
</ol>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
  \textrm{Pr}\left[h\leftarrow H_k; (x, x')\leftarrow A(h):x\neq x', h(x)=h(x')\right]<k^{-c}
  \end{equation} %]]></script>

<p>for sufficiently large <script type="math/tex">k</script>.</p>

<p>Damgård gave a constructive proof of their existence, on the assumption that there exist families of one-way “claw-free” permutations [Dam 87]. More generally, any “one-way group action” is sufficient [BY 90]. Concretely, the construction can be based on the difficulty either of factoring or of the discrete logarithm function. (As usual, the collision adversary <script type="math/tex">A</script> in condition (3) above can be uniform or non-uniform, depending on the precise form of the hypothesis made on the computational complexity of the underlying problem.) For a variety of reasons, none of the known theoretical constructions of collision-free hash functions are practical.</p>

<p>In practice, the infeasibility of computing collisions for a particular hash function depends on the current state of the art, both the current state of algorithmic knowledge about attacking the function in question, as well as the computational speed and memory available in the best current computers. As the state of the art advances, it is likely that a function that was once securely one-way will eventually cease to be so. For example, Dobbertin’s recently announced attacks on MD4 and MD5 have considerably reduced the community’s confidence in the strength of these two functions [Dob 96a, Dob 96b, Dob 96c]. In §5 below, we offer a solution to the problem this poses for certain practical systems whose real-world security depends on the actual infeasibility of specific computational tasks.</p>

<p>We refer the reader to [Pre 93] for a thorough discussion of one-way hash functions.</p>

<h4 id="theoretical-model">2.3 Theoretical model</h4>
<p>We emphasize that this is a theoretical description of a the problem of verifiably “naming” bit-strings, which is only a piece of the larger problem of naming digital documents.</p>

<p>The setting for our problem is a distributed network of parties. The network may include a <em>server</em> <script type="math/tex">S</script> as well as a <em>repository</em> <script type="math/tex">R</script>; parties may query the repository, asking for a copy of a particular item it contains.</p>

<p><strong>Definition</strong> A <em>naming scheme</em> for this setting consists of:</p>

<p>a <em>security parameter</em> k;
a polynomial-time <em>naming protocol</em> <script type="math/tex">N</script>, possibly requiring interaction with the server <script type="math/tex">S</script>, taking as input a bit-string <script type="math/tex">x</script>, and producing as output a <em>name</em> <script type="math/tex">n</script> for <script type="math/tex">x</script>, a <em>certificate</em> <script type="math/tex">c</script>, and the addition of items to the repository <script type="math/tex">R</script>; and
a polynomial-time <em>validation protocol</em> <script type="math/tex">V</script>, that takes as input a triple <script type="math/tex">(x, n, c)</script> and the result of a query to <script type="math/tex">R</script>, and either accepts or rejects its inputs.</p>

<p>If <script type="math/tex">(n, c)</script> is the output of an invocation of <script type="math/tex">N</script> on input <script type="math/tex">x</script>, then <script type="math/tex">V</script> accepts the input <script type="math/tex">(x, n, c)</script> when it is accompanied by a correct response to a query to <script type="math/tex">R</script>.</p>

<p>It is possible, of course, to specify a naming scheme that does not require a server or a repository. In that case, the naming protocol and the validation may simply be algorithms that any party in the network may invoke without interacting with outside parties.</p>

<p><strong>Definition</strong> A <em>counterfeiting adversary</em> to a naming scheme <script type="math/tex">[N, V, S]</script> is a (possibly probabilistic) algorithm <script type="math/tex">A</script> that performs as follows. Given <script type="math/tex">k</script> as input, <script type="math/tex">A</script> produces (polynomially many) naming requests <script type="math/tex">x_1, x_2,\ldots</script>; for each <script type="math/tex">x_i</script> <script type="math/tex">A</script> is given the output of <script type="math/tex">N(x_i)</script>. The request <script type="math/tex">x_{i+1}</script> may be computed after <script type="math/tex">A</script> has received the response to its <script type="math/tex">i</script>th request. In addition, <script type="math/tex">A</script> may make (polynomially many) queries to <script type="math/tex">R</script>. Finally (after <script type="math/tex">q</script> naming requests, say), <script type="math/tex">A</script>’s output is of the form <script type="math/tex">(x,n,c)</script>. This output is a <em>successful counterfeit</em> if <script type="math/tex">x\neq x_i</script> (for <script type="math/tex">i=1\ldots q)</script> and <script type="math/tex">V</script> accepts <script type="math/tex">(x,n,c)</script> (after a correct response to any queries to <script type="math/tex">R</script>).</p>

<p><strong>Definition</strong> A naming scheme is <em>secure</em> if for any polynomially bounded counterfeiting adversary <script type="math/tex">A</script> and for any positive constant <script type="math/tex">c</script>, <script type="math/tex">A</script>’s success probability on input <script type="math/tex">k</script> is less than <script type="math/tex">k^{-c}</script> for sufficiently large <script type="math/tex">k</script>.</p>

<p>To illustrate our definitions, here is a simple example of a naming scheme, where the only role of the server is to announce its random choice of a hash function <script type="math/tex">h\in H_k</script>.The naming procedure is just <script type="math/tex">N(x) = h(x)</script> with no certificates, and <script type="math/tex">V</script> accepts <script type="math/tex">(x, n)</script> if <script type="math/tex">n = h(x)</script>. It is clear that this defines a secure naming scheme as long as <script type="math/tex">H_k</script> is the <script type="math/tex">k</script>th set in a family of collision-free hash functions.</p>

<p>We remark that the roles of <script type="math/tex">S</script> as trusted server and <script type="math/tex">R</script> as trustworthy repository in these definitions are just an artifact of how we have chosen to present and to analyze our naming schemes, allowing a clean separation between issues of the security of the scheme itself and issues of how it might be implemented in practice.</p>

<h4 id="digital-time-stamping">2.4 Digital time-stamping</h4>
<p>Our solution to the naming problem builds on the work of [HS 91] and [BHS 93], whose authors describe several procedures with which users can <em>certify</em> (the bit-string contents of) their digital documents, computing for any particular document a time-stamp <em>certificate</em>. Later, any user of the system can <em>validate</em> a document-certificate pair; that is, he or she can use the certificate to verify that the document existed, in exactly its current form, at the time asserted in the certificate. It is infeasible to compute an illegitimate document-certificate pair that will pass the validation procedure.</p>

<p>Because we use it directly in our naming scheme, we summarize here one digital time-stamping scheme. A central “coordinating server” receives <em>certification</em> requests essentially, hash values of files—from users. At regular intervals, the server builds a binary tree out of all the requests received during the interval, following Merkle’s tree authcntication technique; the leaves are the requests, and each internal node is the hash of the concatenation of its two children [Merk 80]. The root of this tree is hashed together with the previous “interval hash” to produce the current interval hash, which is placed in a widely available <em>repository</em>. The server then returns to each requester a time-stamp <em>certificate</em> consisting of the time at which the interval ended, along with the list of sibling hash values along the path leading from the requester’s leaf up to the interval hash, each one accompanied by a bit indicating whether it is the right or the left sibling. The scheme also includes a <em>validation</em> procedure, allowing a user to test whether a document has been certified in exactly its current form, by querying the repository for the appropriate interval hash, and comparing it against a hash value appropriately recomputed from the document and its certificate.</p>

<p>It is noteworth that the trustworthiness of the certificates computed in this scheme depends only on the integrity of the repository, and not (for example) on trusting that a particular private key has not been compromised or that a particular party’s computation has been performed correctly.</p>

<h3 id="a-naming-scheme-for-bit-strings">3 A naming scheme for bit strings</h3>
<p>Next we describe a naming scheme for a network that includes a server <script type="math/tex">S</script> and a repository <script type="math/tex">R</script>. Many executions of <script type="math/tex">N</script> and of <script type="math/tex">V</script> may be performed concurrently in the network. We assume that there exists a family <script type="math/tex">\{H_k\}_k</script> of collision-free hash functions. Given an initial choice of security parameter <script type="math/tex">k</script>, <script type="math/tex">S</script> announces to all parties its random choice of a one-way hash function <script type="math/tex">h\in H_k</script>. Our scheme is a variation on the time-stamping scheme described in §2.4 above, with <script type="math/tex">S</script> playing the role of the coordinating server that computs certificates in response to requests and makes additions to the repository <script type="math/tex">R</script>.</p>

<p>We abbreviate a bit-string’s certificate by omitting the list of hash values, leaving only a pointer to the relevant interval hash (for example, the time at which it was computed), and an encoding of the position of the request in the tree for that interval (for example, the sequence of left or right bits). It is this abbreviation that we propose to use as the name of the bit-string.</p>

<p>More explicitly, an invocation of <script type="math/tex">N</script> on input <script type="math/tex">x</script> begins with the computation of <script type="math/tex">y=h(x)</script>, and the submittion of <script type="math/tex">y</script> to <script type="math/tex">S</script>, which includes <script type="math/tex">y</script> as one of hte leaves of the tree being built in the current time interval. At the end of the interval, having built a atree of height <script type="math/tex">l</script> (that includes the previous interval hash), <script type="math/tex">S</script> places the root of the tree in <script type="math/tex">R</script> as the current interval hash with label <script type="math/tex">t</script>, say. <script type="math/tex">S</script> responds to the request by returning the certificate <script type="math/tex">c=[t;(z_1,b_1),\ldots,(z_l,b_l)]</script>, where each <script type="math/tex">b_l=\textrm{L or R}</script>. Finally, the name returned by <script type="math/tex">N</script> for argument <script type="math/tex">x</script> is <script type="math/tex">n=[t;b_1,\ldots,b_l]</script>.</p>

<p>One uses the entire certificate in order to validate that a particular string correctly names a particular bit-string document, first by checking that the putative name was correctly extracted from the certificate, and then by following the usual validation procedure for the document-certificate pair (recomputing the path from the leaf to the root of the tree).</p>

<p>To be precise, <script type="math/tex">V</script> operates as follows, given as inputs a document <script type="math/tex">x</script>, a name <script type="math/tex">n=[t;b_1,\ldots,b_l]</script>, and a certificate <script type="math/tex">c=[t';(z_1,b_1'),\ldots,(z_l,b_l')]</script>: First, <script type="math/tex">V</script> checks that <script type="math/tex">t=t'</script> and that each <script type="math/tex">b_l=b_l'</script>. Next, <script type="math/tex">V</script> computes <script type="math/tex">y_1\leftarrow h(x)</script> and then (for <script type="math/tex">i\leftarrow 1\ldots l)</script> if <script type="math/tex">b_l=\textrm{L}</script> then <script type="math/tex">y_{i+1}\leftarrow h(z_i \cdot y_i)</script> else if <script type="math/tex">b_l=\textrm{R}</script> then <script type="math/tex">y_{i+1}\leftarrow h(y_i\cdot z_i)</script>. Finally, <script type="math/tex">V</script> queries <script type="math/tex">R</script> for the hash value stored at location <script type="math/tex">t</script>, and checks that it is identical to <script type="math/tex">y_{l+1}</script>. <script type="math/tex">V</script> accepts if all these checks are satisfied and rejects otherwise.</p>

<p>Figure 1 below illustrates the tree built by <script type="math/tex">S</script> for a time interval during which it received eight requests, containing the eight hash values <script type="math/tex">a,b,c,d,e,f,g</script>, and <script type="math/tex">h</script>. In this diagram, <script type="math/tex">ab</script> is the hash of the concatenation of <script type="math/tex">a</script> and <script type="math/tex">b</script>, etc., and <script type="math/tex">IH_t</script> and <script type="math/tex">IH_{t-1}</script> are the respective interval hashes for the current and the previous intervals. The certificate computed by <script type="math/tex">S</script> for the third request (the one containing hash value <script type="math/tex">c</script>), for example, is the following:</p>

<script type="math/tex; mode=display">\begin{equation}
[t; (d,\textrm{R}, (ab,\textrm{L}), (eg, \textrm{R}), (IH_{t-1}, \textrm{L}))].
\end{equation}</script>

<p><img src="secure-names-bit-strings/hash-tree.png" alt="hash-tree.png" /></p>

<h4 id="security">3.1 Security</h4>
<p>The security of this naming scheme follows directly from the infeasibility of computing hash collisions for functions from <script type="math/tex">\{H_k\}_k</script>, since the only possible counterfeit names include hash collisions. In essence, if <script type="math/tex">x</script> is a bit-string on which <script type="math/tex">N</script> was never invoked during a run, any triple <script type="math/tex">x,n,c</script> that <script type="math/tex">V</script> will accept (after the correct response to a query to <script type="math/tex">R</script>) will include a hash collision for the function <script type="math/tex">h</script> announced by <script type="math/tex">S</script> at the beginning of the run: either <script type="math/tex">x</script> itself or one of the hash values <script type="math/tex">z_t</script> in <script type="math/tex">c</script> (when combined on the left or the right with <script type="math/tex">y_i</script>) collides with another argument to <script type="math/tex">h</script> whose hash value was computed during the run. Therefore we have the following theorem.</p>

<p><strong>Theorem 1</strong> <em>If <script type="math/tex">\{H_k\}_k</script> is a family of collision-free hash functions, then the naming scheme [N,V,S] described above is secure</em></p>

<p>Because the reduction in the proof is so direct, it is easy to give an “exact security” analysis (cf. [Lev 85, BKR 94]) of the strength of this scheme, whether the hash functions used are from the collision-free family provided by a theoretical cryptographic assumption or rather practical hash functions, as in the implementations described in §6 below.</p>

<h4 id="variations-on-the-scheme">3.2 Variations on the scheme</h4>
<p>Of course, the secure verifiability of the names assigned by the scheme described above does not depend on the particular combination of binary trees and linked lists used. By systematically invoking the hash function on pairs or ordered lists of hash values, new hash values can be computed from old ones so as to form a directed acyclic graph (by directing an edge from each of the inputs to the hash value output). Design considerations (including those discussed in §6.1 below) may dictate several different combinatorial structures for this directed graph.</p>

<p>Whatever the structure of the growing graph of hash values, it is secured by making portions of the graph widely witnessed and widely available. To insure the verifiability of the names, it suffices that every document in the naming structure be linked by a directed path to a widely witnessed hash value; a standard ordering of the incoming edges at each node can be used to encode the path. Then the name of a document is given by this encoding of its location in the graph, together with a pointer to the hash value at the end of the path, and the argument of Theorem 1 applies.</p>

<p>For example, in one variation of the scheme described above, a list of documents may be used to build a local tree (following Merkle, again), whose root is sent off in turn as a request to the coordinating server. The location information for a document in this “tree-of-trees” scheme can be written as a position in the server’s tree followed by a position in the local tree.</p>

<p>In another variation, the widely witnessed hash values in the repository could consist simply of a linked list (as in the simple linking scheme of [HS 91]). In this case the location information for a document is a simple pointer into the repository.</p>

<h3 id="applications">4 Applications</h3>
<p>The problem of naming digital documents might have seemed like a curiosity only a few years ago. However, with the growth in use of the Internet, more and more people need to be able to refer confidently to meaningful bit-sequences. The problem is now a matter of immediate practical concern.</p>

<p>The problem has become especially acute with the emergence of the World-Wide Web. Jumping from one URL (Uniform Resource Locator) to the next in a sequence of WWW documents may seem at first to be exactly analogous to following a bibliographic reference in a traditional scholarly paper. In fact it is something quite different: a URL is only a pointer to a location, with no guarantee that what a user finds there today is the same reference that the author originally intended. If on-line citations include secure names for the bit-string contents of the documents cited, then it is possible to traverse a path of citations with confidence that one is indeed following the authors’ intentions. This abiity would be especially useful for the many documents on the World-Wide Web that exist only on-line.</p>

<p>In most electronic commerce systems, transaction records of all sorts are kept on-line, and it would be useful to have a cryptographically secure means of assigning serial numbers or tracking numbers to these records.</p>

<p>Software code is another class of digital document for which it would be useful to have an easy way for a short name to carry a guarantee of integrity. A user who downloads software (along with its naming certificate) from a site on the Net can be sure of its integrity if he or she is able to check that the code is correctly named by a short string of letters and numbers. Here, of course, bit-string equality is <em>exactly</em> the point. The great strength of using secure names in thii application is that the short name of a program is considerably easier to distribute widely and robustly than the program itself. (It is also easier to distribute reliably than the sort of public-key infrastructure information that is required in order to use digital signatures in order to validate the integrity of code.)</p>

<p>For another example of a type of large digital document whose integrity matters a great deal, consider the case of genetic data. Scientists now routinely download others’ data sets for use in their own research. The use of our naming scheme would allow the user to be sure of the data’s integrity, as well as providing a convenient and verifiable way to cite the data in published descriptions of the work that was done with it.</p>

<h3 id="long-lived-names">5. Long-lived names</h3>
<p>The technique described in [BHS 93] for renewing cryptographic certifications of authenticity applies directly to the certificates of the present naming scheme.</p>

<p>The renewing process works as follows. Let us suppose that an implementation of a particular time-stamping system is in place, and consider the pair <script type="math/tex">(z,C)</script>, where <script type="math/tex">C</script> is a valid time-stamp certificate (in this implementation) for the bit-string <script type="math/tex">x</script>. Now suppose that an improved time-stamping system is implemented and put into practice—by replacing the hash function used in the original system with a new hash function, or even perhaps after the invention of a completely new algorithm. Further suppose that the pair <script type="math/tex">(x, C)</script> is time-stamped by the new system, resulting in a new certificate <script type="math/tex">C’</script>, and that. some time later, i.e. at a definite later date, the original method is compromised. <script type="math/tex">C’</script> provides evidence not only that the document contents <script type="math/tex">x</script> existed prior to the time of the new time-stamp, but that it existed at the time stated in the original certificate, <script type="math/tex">C</script>; prior to the compromise of the old implementation, the only way to create a certificate was by legitimate means. (It is similarly recommended that if a digitally signed document is likely to be important for a long time-perhaps longer than the signer’s key will be valid-then the document-signature pair should be time-stamped [BHS 93, Odl 95, HKS 95].)</p>

<p>In our naming schemes, the verifiable name for the bit-string <script type="math/tex">x</script> is a standard abbreviation <script type="math/tex">a</script> for its original certificate <script type="math/tex">C</script>. In order that a continue to be verifiable as a name for <script type="math/tex">t</script>, the certificate <script type="math/tex">C</script> should be renewed (as above) from time to time as new time-stamping systems are put in place. As long as this is done, <script type="math/tex">a</script> is still a verifiable name for <script type="math/tex">x</script>. There is now an additional step to the procedure for validating the name: after checking that <script type="math/tex">a</script> is correctly extracted from <script type="math/tex">C</script>, one must follow the usual time-stamp validation procedure for the certificate, which now includes both the originalsystem validation of <script type="math/tex">(x,C)</script> and the new-system validation of <script type="math/tex">[(x, C), C’]</script>. We note that in practice this additional validation step would be automated, and would not at all affect the convenient use of <script type="math/tex">a</script> to name <script type="math/tex">x</script>.</p>

<h3 id="practical-implementations">6. Practical implementations</h3>
<p>A practical implementation of a naming scheme cannot use the known theoretical constructions of collision-free hash functions. If the decision is made to use practical one-may hash functions such as MD5, then users of the system do not need to trust the server’s random choice of a function <script type="math/tex">h\in H_k</script>. (However, they do have to hope that the hash function chosen is one-way in practice; see section §5 for one way to allay users’ concerns on this score.)</p>

<p>The naming scheme described in §3 above, based on the digital time-stamping scheme described in $2.4, was implemented by Surety Technologies, and has been in continuous commercial use since January 1995. The implementation uses practical hash functions; SpecificaIly, the current implementation uses <script type="math/tex">h(x) = (MD5(x),SHA(x))</script> as the hash value for any argument <script type="math/tex">x</script>. A number of supplemental mechanisms are employed in order to maintain the integrity and wide distribution of the repository [Sur 95].</p>

<p>The names assigned by our scheme are indeed concise, growing essentially as slowly as possible while still providing unique names. If the repository contains <script type="math/tex">n</script> interval hashes, and no more than <script type="math/tex">m</script> naming requests are received during each interval, the names can be written with at most <script type="math/tex">\log_2 nm</script> bits. Just to give a numerical example, a repository representing a thousand requests per minute for the length of a century requires 36-bit names; in the MIME encoding (six bits per alphanumeric character) such a name can be jotted down with six characters, while hash-value names of this length are completely insecure.</p>

<h4 id="meaningful-names">6.1 Meaningful names</h4>
<p>There are several variations of our naming scheme that allow an author a fair measure of control over the names of his or her documents, so that the author can choose a verifiable name that is meaningful in one or another useful way.</p>

<p>First, and most obviously, observe that in the scheme described in detail in §3 a convenient way to encode the location in the repository to which a document’s contents are linked is by the date and time at which the interval hash at that location was computed. Instead of (e.g.) a MIME encoding of the number of seconds since a moment in early 1970 (Unix standard time), it would often be useful to express at least a part of this date and time in human-readable form.</p>

<p>In a slight variation, we can allow “personalized” naming requests, as follows. Suppose that the repository items are formatted in a standard way every day, and let <script type="math/tex">F(\cdot)</script> denote any standard mapping from ASCII-encoded strings to the list of daily repository locations. When the server receives a personalized naming request that includes the ASCII string <script type="math/tex">s</script>, the request is held until the appropriate moment in the day and then linked to the widely witnessed hash value stored at location <script type="math/tex">F(s)</script>; in this way, s is made to be part of the name of the documents included in those special naming requests. Thus, for example, the author of <em>The History of Computers in Zurich</em> can arrange for the verifiable name of its bit-string contents to have the form [“The History of Computers in Zurich” <code>date suffix</code>], where <code>suffix</code> includes a few bits of disambiguating information that distinguishes this request from all others that mere linked to the same repository location.</p>

<p>In another example, consider the tree-of-trees variation briefly mentioned in §3.2. An author can name a multi-part document by placing the contents of each successive part at consecutive leaf nodes of a local tree. The resulting request to the server gives the consecutive parts of the document consecutive local positions and therefore consecutive names. Furthermore, the other portions of these consecutive names are identical, explicitly encoding the fact that they are parts of the same document. And local trees can have sub-trees, so that our historian can arrange to name the ith section of the jth chapter of his masterpiece [“The History of Computers in Zurich” <code>infix</code> <script type="math/tex">i,j</script>], for all appropriate pairs <script type="math/tex">(i,j)</script>.</p>

<p>More complicated ways of structuring the parts of a document can similarly be encoded in the verifiable names assigned by our naming scheme. Note that conventional naming schemes do allow for encoding document structure into names, but not in a verifiable manner.</p>

<p>In another variation, a table of contents for a long or complicated multi-part document can be included in a standard place in the request—for example, as its last piece. The table of contents may contain more or less detailed descriptions of the parts of the document. At a later time, together with a list of documents to be authenticated and their certificates, such an authenticated table of contents can be used to verify (1) that each document in the list is an exact copy of one that was registered with the table of contents, and (2) that none of the documents in the list are missing.</p>

<h3 id="acknowledgements">Acknowledgements</h3>

<p>We would like to thank Ralph Merkle, R. Venkatesan, Matt Franklin, Avi Rubin, Bill Arms, and Dave Richards for helpful discussions about this work. We would also like to thank the anonymous referees for their very useful suggestions.</p>

<h3 id="references">References</h3>
<p>See <a href="secure-names-bit-strings.pdf">original</a>.</p>

        </div>

      </section>

      <footer>
  <social>
  <!--email_off-->
    <a href="mailto:dsuo@cs.princeton.edu" target="_blank"><i class="fa fa-envelope fa-1x"></i></a>
  <!--/email_off-->
  <a href="https://github.com/danielsuo" target="_blank"><i class="fa fa-github fa-1x"></i></a> 
  <a href="http://www.linkedin.com/in/danielsuo" target="_blank"><i class="fa fa-linkedin fa-1x"></i></a>
  <a href="http://twitter.com/danielsuo" target="_blank"><i class="fa fa-twitter fa-1x"></i></a>
  <a href="/feed.xml" target="_blank"><i class="fa fa-rss fa-1x"></i></a> 
</social>
  <br>
  
  <!--email_off-->
    <small>Complain <a href="mailto:dsuo@cs.princeton.edu" target="_blank">here</a>.</small>
  <!--/email_off-->
  <small><a href="/pubkey.txt" target="_blank">Securely</a>.</small>
</footer>
      
    </div>

    <script src='/assets/js/scale.fix.js'></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37351701-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>