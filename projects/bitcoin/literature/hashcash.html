<!doctype html>
<html>
  
  <head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Daniel Suo | Scientific progress goes 'boink'</title>

<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/pygment_trac.css">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/assets/img/profile.jpg" />

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
</head>

  <body id='Hashcash - A Denial of Service Counter-Measure'>
    
    <div class='wrapper'>
      
      <header>
    <h1>Daniel Suo</h1>
    <p>Scientific progress goes 'boink'</p>
    
    <ul>
    	<li><a href="/" id="home">home</a></li>
    	<li><a href="/archive" id="archive">archive</a></li>
        <li><a href="/projects" id="reading">projects</a></li>
    </ul>

    <div class="cb-tip-button" data-content-location="" data-href="//www.coinbase.com/tip_buttons/show_tip" data-to-user-id="515097e7e82052a271000007"></div>
    <script>!function(d,s,id) {var js,cjs=d.getElementsByTagName(s)[0],e=d.getElementById(id);if(e){return;}js=d.createElement(s);js.id=id;js.src="https://www.coinbase.com/assets/tips.js";cjs.parentNode.insertBefore(js,cjs);}(document, 'script', 'coinbase-tips');</script>
</header>

      <section>

        <div id='container'>
          <h2 id="hashcash---a-denial-of-service-counter-measure">Hashcash - A Denial of Service Counter-Measure</h2>
<p>Adam Back (<a href="hashcash.pdf">original</a>)</p>

<h3 id="abstract">Abstract</h3>
<p><em>Hashcash</em> was originally proposed as a mechanism to throttle systematic abuse of un-metered internet resources such as email, and anonymous remailers in May 1997. Five years on, this paper captures in one place the various applications, improvements suggested and related subsequent publications, and describes initial experience from experiments using hashcash.</p>

<p>The <em>hashcash</em> CPU cost-function computes a token which can be used as a proof-of-work. Interactive and noninteractive variants of cost-functions can be constructed which can be used in situations where the server can issue a challenge (connection oriented interactive protocol), and where it can not (where the communication is store–and–forward, or packet oriented) respectively.</p>

<h3 id="introduction">1. Introduction</h3>
<p>Hashcash [1] was originally proposed as a mechanism to throttle systematic abuse of un-metered internet resources such as email, and anonymous remailers in May 1997. Five years on, this paper captures in one place the various applications, improvements suggested and related subsequent publications, and describes initial experience from experiments using hashcash.</p>

<p>The <em>hashcash</em> CPU cost-function computes a token which can be used as a proof-of-work. Interactive and noninteractive variants of cost-functions can be constructed which can be used in situations where the server can issue a challenge (connection oriented interactive protocol), and where it can not (where the communication is store–and–forward, or packet oriented) respectively.</p>

<p>At the time of publication of [1] the author was not aware of the prior work by Dwork and Naor in [2] who proposed a CPU pricing function for the application of combatting junk email. Subsequently applications for cost functions have been further discussed by Juels and Brainard in [3]. Jakobsson and Juels propose a dual purpose for the work spent in a cost-function: to in addition perform an otherwise useful computation in [4].</p>

<h3 id="cost-functions">2. Cost-Functions</h3>
<p>A <em>cost-function</em> should be efficiently verifiable, but parameterisably expensive to compute. We use the following notation to define a cost-function.</p>

<p>In the context of cost-functions we use <em>client</em> to refer to the user who must compute a <em>token</em> (denoted <script type="math/tex">\mathcal{T}</script>) using a cost-function <script type="math/tex">\textrm{MINT}()</script> which is used to create tokens to participate in a protocol with a server. We use the term mint for the cost-function because of the analogy between creating cost tokens and minting physical money.</p>

<p>The server will check the value of the token using an evaluation function <script type="math/tex">\textrm{VALUE}()</script>, and only proceed with the protocol if the token has the required value.</p>

<p>The functions are parameterised by the amount of work <script type="math/tex">w</script> that the user will have to expend on average to mint a token.</p>

<p>With <em>interactive cost-functions</em>, the server issues a challenge <script type="math/tex">\mathcal{C}</script> to the client—the server uses the <script type="math/tex">\textrm{CHAL}()</script> function to compute the challenge. (The challenge function is also parameterised by the work factor.)</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \mathcal{C} & \leftarrow & \textrm{CHAL}(s,w) & \textrm{server challenge function} \\
  \mathcal{T} & \leftarrow & \textrm{MINT}(\mathcal{C}) & \textrm{mint token based on challenge} \\
  \mathcal{V} & \leftarrow & \textrm{VALUE}(\mathcal{T}) & \textrm{token evaluation function} \\
\end{cases} %]]></script>

<p>With <em>non-interactive cost-functions</em> the client chooses its own challenge or random start value in the <script type="math/tex">\textrm{MINT}()</script> function, and there is no <script type="math/tex">\textrm{CHAL}()</script> function.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \mathcal{T} & \leftarrow & \textrm{MINT}(s,w) & \textrm{mint token} \\
  \mathcal{V} & \leftarrow & \textrm{VALUE}(\mathcal{T}) & \textrm{token evaluation function} \\
\end{cases} %]]></script>

<h4 id="publicly-auditable-probalistic-cost">2.1 Publicly Auditable, Probalistic Cost</h4>
<ul>
  <li>A <em><strong>publicly auditable</strong></em> cost-function can be <em>efficiently</em> verified by any third party without access to any trapdoor or secret information. (When we say <em>publicly auditable</em> we mean implicitly that the cost-function is <em>efficiently</em> publicly auditable compared to the cost of minting the token, rather than auditable in the weaker sense that the auditor could repeat the work done by the client.)</li>
  <li>A <em><strong>fixed cost</strong></em> cost-function takes a fixed amount of resources to compute. The fastest algorithm to mint a fixed cost token is a deterministic algorithm.</li>
  <li>
    <p>A <em><strong>probabilistic cost</strong></em> cost-function is one where the cost to the client of minting a token has a predictable expected time, but a random actual time as the client can most efficiently compute the cost-function by starting at a random start value. Sometimes the client will get lucky and start close to the solution.</p>

    <p>There are two types of probabilistic cost <em>bounded probabilistic cost</em> and <em>unbounded probabilistic cost</em>.</p>

    <ul>
      <li>An <em><strong>unbounded probabilistic cost</strong></em> cost-function, can in theory take forever to compute, though the probability of taking significantly logner than expected decreases rapidly towards zero. (An example would be the cost-function of being required to throw a head with a fair coin; in theory the user could be unlucky and end up throwing many tails, but in practice the probability of not throwing a head for <script type="math/tex">k</script> throws tends towards <script type="math/tex">0</script> rapidly as <script type="math/tex">\lim_{k\rightarrow infty} \left(\frac{1}{2}\right)^k = 0</script>.)</li>
      <li>With a <em><strong>bounded probabilistic cost</strong></em> cost-function there is a limit to how unlucky the client can be in its search for the solution; for example where the client is expected to search some key space for a known solution; the size of the key space imposes an upper bound on the cost of finding the solution.</li>
    </ul>
  </li>
</ul>

<h4 id="trapdoor-free">2.2 Trapdoor-free</h4>
<p>A disadvantage of known solution cost-functions is that the challenger can cheaply create tokens of arbitrary value. This precludes public audit where the server may have a conflict of interests, for example in web hit metering, where the server may have an interest to inflate the number of hits on its page where it is being paid per hit by an advertiser.</p>

<ul>
  <li>A <em><strong>trapdoor-free</strong></em> cost-function is one where the server has no advantage in minting tokens.</li>
</ul>

<p>An example of a trapdoor-free cost-function is the Hashcash [1] cost-function. Juels and Brainard’s client-puzzle cost-function is an example of a <em>known-solution</em> cost-function where the server has an advantage in minting tokens. Client-puzzles as specified in the paper are in addition not publicly auditable, though this is due to a storage optimization and not inherent to their design.</p>

<h3 id="the-hashcash-cost-function">The Hashcash cost-function</h3>

<p>Hashcash is a non-interactive, publicly auditable, trapdoor-free cost function with unbounded probabilistic cost.</p>

<p>First we introduce some notation: consider the bitstring <script type="math/tex">s=\{0,1\}^*</script>, we define <script type="math/tex">[s]_i</script> to mean the bit at offset <script type="math/tex">i</script>, where <script type="math/tex">[s]_1</script> is the left-most bit, and <script type="math/tex">[s]_{\|s\|}</script> is the right-most bit. <script type="math/tex">[s]_{i\ldots j}</script> means the bit-wise substring between and including bits <script type="math/tex">i</script> and <script type="math/tex">j</script>, <script type="math/tex">[s]_{i\ldots j}=[s]_i \| \ldots \| [s]_j</script>. So <script type="math/tex">s=[s]_{1\ldots \|s\|}</script>.</p>

<p>We define a binary infix comparison operator <script type="math/tex">\stackrel{\textrm{left}}{=}_b</script> where <script type="math/tex">b</script> is the length of the common left-substring from the two bit-strings.</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{eqnarray}
   x \stackrel{\textrm{left}}{=}_0 y && [x]_1 \neq [y]_1 \\
   x \stackrel{\textrm{left}}{=}_b y && [x]_i = [y]_i, \forall_{i=1\ldots b}
\end{eqnarray} %]]></script>

<p>Hashcash is computed relative to a service-name <script type="math/tex">s</script>, to prevent tokens minted for one server being used on another (servers only accepted tokens minted using their own service-name). The service-name can be any bit-string which uniquely identifies the service (e.g., host name, email address, etc).</p>

<p>The hashcash function is defined as (note this is an improved simplified variant since initial publication. See note in section 5):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \textrm{PUBLIC}: & \textrm{hash function } \mathcal{H}(\cdot) \textrm{ with output size} k \textrm{bits} \\
  \mathcal{T}\leftarrow\textrm{MINT}(s,w) & \textbf{find } x\in_R \{0,1\}^* \textbf{ s.t. } \mathcal{H}(s\|x)\stackrel{\textrm{left}}{=}_w 0^k \\
  & \textbf{return } (s,x) \\
  \mathcal{V}\leftarrow\textrm{VALUE}(\mathcal{T}) & \mathcal{H}(s\|x)\stackrel{\textrm{left}}{=}_v 0^k\\
  & \textbf{return } v
\end{cases} %]]></script>

<p>The hashcash cost-function is based on finding partial hash collisions on the all <script type="math/tex">0</script> bits <script type="math/tex">k</script>-bit string <script type="math/tex">0^k</script>. The fastest algorithm for computing partial collisions is brute force. There is no challenge as the client can safely choose his own random challenge, and so the hashcash cost-function is a <em>trapdoor-free</em> and <em>non-interactive</em> cost-function. In addition the Hashcash cost-function is <em>publicly auditable</em>, because anyone can efficiently verify any published tokens. (In practice <script type="math/tex">\|x\|</script> should be chosen to be large enough to make the probability that clients reuse a previously used start value negligible; <script type="math/tex">\|x\| = 128</script> bits should be enough even for a busy server.)</p>

<p>The server needs to keep a double spending database of spent tokens, to detect and reject attempts to spend the same token again. To prevent the database growing indefinitely, the service string can include the time at which it was minted. This allows the server to discard entries from the spent database after they have expired. Some reasonable expiry period should be chosen to take account of clock inaccuracy, computation time, and transmission delays.</p>

<p>Hashcash was originally proposed as a counter-measure against email spam, and against systematic abuse of anonymous remailers. It is necessary to use <em>non-interactive cost-functions</em> for these scenarios as there is no channel for the server to send a challenge over. However one advantage of <em>interactive cost-functions</em> is that it is possible to prevent pre-computation attacks. For example, if there is a cost associated with sending each email this may be sufficient to limit the scale of email abuse perpetrated by spammers; however for a pure DoS-motivated attack a determined adversary may spend a year pre-computing tokens to all be valid on the same day, and on that day be able to temporarily overload the system.</p>

<p>It would be possible to reduce the scope for such pre-computation attacks by using a slowly changing beacon (unpredictable broadcast authenticated value changing over time) such as say this weeks winning lottery numbers. In this event the current beacon value is included in the start string, limiting pre-computation attacks to being conducted within the time period between beacon value changes.</p>

<h3 id="interactive-hashcash">4. Interactive Hashcash</h3>
<p>With the interactive form of hashcash, for use in interactive settings such as TCP, TLS, SSH, IPSEC etc connection establishment a challenge is chosen by the server. The aim of interactive hashcash is to defend server resources from premature depletion, and provide graceful degradation of service with fair allocation across users in the face of a DoS attack where one user attempts to deny service to the other users by consuming as many server resources as he can. In the case of security protocols such as TLS, SSH and IPSEC with computationally expensive connection establishment phases involving public key crypto the server resource being defended is the servers available CPU time.</p>

<p>The interactive hashcash cost-function is defined as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \textrm{C}\leftarrow\textrm{CHAL}(s,w): & \textbf{choose }c\in_R \{0,1\}^k \\
  & \textbf{return } (s,w,c)\\
  \mathcal{T}\leftarrow\textrm{MINT}(s,w) & \textbf{find }x\in_R \{0,1\}^* \textbf{ s.t. } \mathcal{H}(s\|c\|x)\stackrel{\textrm{left}}{=}_w 0^k \\
  & \textbf{return }(s,x)\\
  \mathcal{V}\leftarrow\textrm{VALUE}(\mathcal{T}) & \mathcal{H}(s\|c\|x)\stackrel{\textrm{left}}{=}_v 0^k\\
  & \textbf{return }v
\end{cases} %]]></script>

<h4 id="dynamic-throttling">4.1 Dynamic throttling</h4>
<p>With interactive hashcash it becomes possible to dynamically adjust the work factor required for the client based on server CPU load. The approach also admits the possibility that interactive hashcash challenge-response would only be used during periods of high load. This makes it possible to phase-in DoS resistent protocols without breaking backwards compatibility with old client software. Under periods of high load non-hashcash aware clients would be unable to connect, or would be placed in a limited connection poolsubject to older less effective DoS counter-measures such as random connection dropping.</p>

<p><script type="math/tex"></script> 4.2 hashcash-cookies
With connection-slot depletion attacks such as the syn-flood attack, and straight-forward TCP connection-slot depletion the server resource that is being consumed is space available to the TCP stack to store per-connection state.</p>

<p>In this scenario it may be desirable to avoid keeping per connection state, until the client has computed a token with the interactive hashcash cost-function. This defense is similar to the syn-cookie defense to the syn-flood attack, but here we propose to additionally impose a CPU cost on the connecting machine to reserve a TCP connection-slot.</p>

<p>To avoid storing the challenge in the connection state (which itself consumes space) the server may choose to compute a keyed MAC of the information it would otherwise store and sent it to the client as part of the challenge so it can verify the authenticity of the challenge and token when the client returns them. (This general technique—ofsending a record you would otherwise store together with a MAC to the entity the information is about—is referred to as a <em>symmetric key certificate</em>.) This approach is analogous to the technique used in syn-cookies, and Juels and Brainard proposed a related approach but at the application protocol level in their client-puzzles paper.</p>

<p>For example with MAC function <script type="math/tex">\mathcal{M}</script> keyed by server key <script type="math/tex">K</script> the challenge MAC could be computed as:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \textrm{PUBLIC}: & \textrm{MAC function }\mathcal{M}(\cdot,\cdot)\\
  \mathcal{C}\leftarrow\textrm{CHAL}(w) & \textbf{choose } c\in_R\{0,1\}^k\\
  & \textbf{compute } m \leftarrow \mathcal{M}(K, t\|s\|p\|w\|c) \\
  & \textbf{return } (t,s,p,w,c,m)
\end{cases} %]]></script>

<p>The client must send the MAC <script type="math/tex">m</script>, and the challenge <script type="math/tex">c</script> and challenge parameters <script type="math/tex">p</script> with the response token so that the server can verify the challenge and the response. The server should also include in the MAC the connection parameters, at minimum enough to identify the connection-slot and some time measurement or increasing counter t so that old challenge responses can not be collected and re-used after the connection-slots are free. The challenge and MAC would be sent in the TCP SYN-ACK response message, and the client would include the interactive hashcash token (challenge-response) in the TCP ACK message. As with syn-cookies, the server would not need to keep any state per connection prior to receiving the TCP ACK.</p>

<p>For backwards compatibility with syn-cookie aware TCP stacks, a hashcash-cookie aware TCP stack would only turn on hashcash-cookies when it detected that it was subject to a TCP connection-depletion attack. Similar arguments as given by Dan Bernstein in [5] can be used to show that backwards compatibility is retained, namely under syn-flood attacks Bernstein’s arguments show how to provide backwards compatibility with non syn-cookie aware implementations; similarly under connection-depletion attack hashcash-cookies are only turned on at a point where service would anyway otherwise be unavailable to a non-hashcash-cookie aware TCP stack.</p>

<p>As the flood increases in severity the hashcash-cookie algorithm would increase the collision size required to be in the TCP ACK message. The hashcash-cookie aware client can still connect (albeit increasinly slowly) with a more fair chance against the DoS attacker presuming the DoSer has limited CPU resources. The DoS attacker will effectively be pitting his CPU against all the other (hashcash-cookie aware) clients also trying to connect. Without the hashcashcookie defense the DoSer can flood the server with connection establishments and can more easily tie up all it’s slots by completing n connections per idle connection time-out where n is the size of the connection table, or pinging the connections once per idle connection time-out to convince the server they are alive.</p>

<p>Connections will be handed out to users collectively in rough proportion to their CPU resources, and so fairness is CPU resource based (presuming each user is trying to open as many connections as he can) so the result will be biased in favor of clients with fast processors as they can compute more interactive-hashcash challenge-response tokens per second.</p>

<h3 id="hashcash-improvements">5. Hashcash improvements</h3>
<p>In the initially published hashcash scheme, the target string to find a hash collision on was chosen fairly by using the hash of the service-name (and respectively the service-name and challenge in the interactive setting). A subsequent improvement suggested independently by Hal Finney [6] and Thomas Boschloo [7] for hashcash is to find a collision against a fixed output string. Their observation is that a fixed collision target is also fair, simpler and reduces verification cost by a factor of 2. A fixed target string which is convenient to compare trial collisions against is the <script type="math/tex">k</script>-bit string <script type="math/tex">0^k</script> where <script type="math/tex">k</script> is the hash output size.</p>

<h3 id="low-variance">6. Low Variance</h3>
<p>Ideally cost-function tokensshould take a predictable amount of computing resourcesto compute. Juels and Brainard’s client-puzzle construction provides a probabilistic bounded-cost by issuing challenges with known-solutions, however while thislimits the theoretical worst case running time, it makeslimited practical difference to the variance and typical experienced running time. The technique of using known solutions is also not applicable to the non-interactive setting. It is an open question as to whether there exist probabilistic bounded-cost, or fixed-cost non-interactive cost-functions with the same order of magnitude of verification cost as hashcash.</p>

<p>The other more significant incremental improvement due to Juels and Brainard is the suggestion to use multiple sub-puzzles with the same expected cost, but lower variance in cost. This technique should be applicable to both the non-interactive and interactive variants of hashcash.</p>

<h4 id="non-parallelizability-and-distributed-dos">6.1 Non-Parallelizability and Distributed DoS</h4>
<p>Roger Dingledine, Michael Freedman and David Molnar put forward the argument that non-parallelizable costfunctions are less vulnerable to Distributed DoS (DDoS) in chapter 16 of [8]. Their argument is that non-parallelizable cost-functions frustrate DDoS because the attacker is then unable sub-divide and farm out the work of computing an individual token.</p>

<p>The author described a fixed-cost cost-function in [9] using Rivest, Shamir and Wagner’s time-lock puzzle [10] which also happens to be non-parallelizable. The time-lock puzzle cost-function can be used in either an interactive or non-interactive setting as it is safe for the user to chose their own challenge. The applicability of Rivest et al’s time-lock puzzle as a cost-function was also subsequently observed by Dingledine et al in [8].</p>

<p>For completeness we present the time-lock puzzle based fixed-cost and non-parallelizable cost-function from [9] here:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{cases}
  \textrm{PUBLIC}: & n = pq\\
  \textrm{PRIVATE}: & \textrm{primes } p \textrm{ and } q, \phi(n)=(p-1)(q-1)\\
  \mathcal{C}\leftarrow\textrm{CHAL}(s,w) & \textbf{choose } c\in_R[0,n)\\
  & \textbf{return }(s,c,w)\\
  \mathcal{T}\leftarrow\textrm{MINT}(\mathcal{C}) & \textbf{compute }x\leftarrow\mathcal{H}(s\|c)\\
  & \textbf{compute }y\leftarrow x^{x^w}\mod n \\
  & \textbf{return }(s,c,w,y)\\
  \mathcal{V}\leftarrow\textrm{VALUE}(\mathcal{T}) & \textbf{compute }x\leftarrow\mathcal{H}(s\|c)\\
  & \textbf{compute }z\leftarrow x^w\mod\phi(n)\\
  & \textbf{if } x^z=y\mod n \textbf{ return }w\\
  & \textbf{else return }0
\end{cases} %]]></script>

<p>The client does not <script type="math/tex">\phi(n)</script>, and so the most efficient method for the client to calculate <script type="math/tex">\textrm{MINT}()</script> is repeated exponentiation, which requires <script type="math/tex">w</script> exponentiations. The challenger knows <script type="math/tex">\phi(n)</script> which allows a more efficient computation by reducing the exponent <script type="math/tex">\mod\phi(n)</script>, so the challenger can execute <script type="math/tex">\textrm{VALUE}()</script> with 2 modular exponentiations. The challenger as a side-effect has a trapdoor in computing the cost-function as he can compute <script type="math/tex">\textrm{MINT}()</script> efficiently using the same algorithm.</p>

<p>We argue however that the added DDoS protection provided by non-parallelizable cost-functions is marginal: unless the server restricts the number of challenges it hands out to a recognizably unique client the DDoS attacker can farm out multiple challenges as easily as farm out a sub-divided single challenge, and consume resources on the server at the same rate as before. Further it is not that hard for a single client to masquerade as multiple clients to a server.</p>

<p>Consider also: the DDoS attacker has generally due to the nature of his method of commandeering nodes an equal number of network connected nodes at his disposal as processors. He can therefore in any case have each attack node directly participate in the normal protocol indistinguisably from any legitimate user. This attack strategy is also otherwise optimal anyway as the attack nodes will present a varied set of source addresses which will foil attempts at per-connection fairness throttling strategies and router based DDoS counter-measures based on volume of traffic across IP address ranges. Therefore for the natural attack node marshalling patterns non-parallelizable cost-functions offer limited added resistance.</p>

<p>As well as the arguments against the practical efficacy and value of non-parallelizable cost-functions, to date non-parallelizable cost functions have had orders of magnitude slower verification functions than non-parallelizable cost-functions. Thisis because the non-parallelizable cost-functionsso far discussed in the literature are related to trapdoor public key cryptography constructs which are inherently less efficient. It is an open question as to whether there exist non-parallelizable cost-functions based on symmetric-key (or public-key) constructs with verification functions of the same order of magnitude as those of symmetric-crypto based cost-functions.</p>

<p>While for the application of time-lock puzzles to cost-functions, a reduced public key size could be used to speed up the verification function, this approach introduces risk that the modulus will be factored with the result that the attacker gains a big advantage in minting tokens. (Note: factoring is itself a largely parallelizable computation.)</p>

<p>To combat this the server should change the public parameters periodically. However in the particular case of the public parameters used by time-lock puzzles (which are the same as the RSA modulus used in RSA encryption), this operation is itself moderately expensive, so this operation would not be performed too frequently. It would probably not be wise to deploy software based on key sizes below 768 bits for this aplication, in addition it would help to change keys periodically, say every hour or so. (RSA modulii of 512 bits have recently been factored by a closed group as discussed in [11] and more recently have been demonstrated by Nicko van Someren et al to be factorizable using standard equipment in an office as reported in [12]; DDoS attackers are known be able to muster significant resources, probably easily exceeding those used in this demonstration.)</p>

<p>The time-lock puzzle cost-function also is necessarily trap-door as the server needs a private verification-key to allow it to efficiently verify tokens. The existance of a verification-key presents the added risk of key compromise allowing the attacker to by-pass the cost-function protection. (The interactive hashcash cost-function by comparison is trap-door-free, so there is no key which would allow an attacker a short-cut in computing tokens). In fact if the verification-key were compromised, it could be replaced, but this need adds complexity and administrative overhead as this event needs to be detected and manual intervention or some automated detection triggering key-replacement implemented. </p>

<p>The time-lock puzzle cost-function also will tend to have larger messages as there is a need to communicate planned and emergency re-keyed public parameters. For some applications, for example the syn-cookie and hashcashcookie protocols, space is at a premium due to backwards compatibility and packet size constraints imposed by the network infrastructure.</p>

<p>So in summary we argue that non-parallelizable cost-functions are of questionable practical value in protecting against DDoS attacks, have more expensive verification functions, incur the risk of verification key compromise and attendant key management complexities, have larger messages, and are significantly more complex to implement. We therefore recommend instead the simpler hashcash protocol (or if the public-auditability and non-interactive options are not required Juels and Brainard’s client-puzzles are roughly equivalent).</p>

<h3 id="applications">7. Applications</h3>
<p>Apart from the initially proposed applications for hashcash of throttling DoS against remailer networks and detering emailspam,since publication the following applications have been discussed, explored and in some casesimplemented and deployed:</p>

<ul>
  <li>hashcash-cookies, a potential extension of the syn-cookie as discussed in section 4.2 for allowing more graceful service degradation in the face of connection-depletion attacks. </li>
  <li>interactive-hashcash as discussed in section 4 for DoS throttling and graceful service degradation under CPU overload attacks on security protocols with computationally expensive connection establishment phases. No deployment but the analogous client-puzzle system was implemented with TLS in [13] </li>
  <li>hashcash throttling of DoS publication floods in anonymous publication systems such as Freenet [14], Publius [15], Tangler [16], </li>
  <li>hashcash throttling of service requests in the cryptographic Self-certifying File System [17]</li>
  <li>hashcash throttling of USENET flooding via mail2news networks [18] </li>
  <li>hashcash as a minting mechanism for Wei Dai’s b-money electronic cash proposal, an electronic cash scheme without a banking interface [19]</li>
</ul>

<h3 id="cost-function-classification-scheme">8. Cost-function classification scheme</h3>
<p>We list here a classification of characteristics of cost-functions. We use the following notation to denote the properties of a cost-function:</p>

<script type="math/tex; mode=display">\begin{equation}
([e=\{1,\frac{1}{2},0\}],[\sigma=\{1,\frac{1}{2},0\}],[\{i,\bar{i}\}],[\{a,\bar{a}\}],[\{t,\bar{t}\}],[\{p,\bar{p}\}])
\end{equation}</script>

<p>Where <script type="math/tex">e</script> is the efficiency: value <script type="math/tex">e=1</script> means <em>efficiently-verifiable</em>—verifiable with cost comparable to or lower than the cost of verifying symmetric key constructs such as hashcash which consume just a single compression round of an iterative compression function based hash function such as SHA1 or MD5. Value <script type="math/tex">e=\frac{1}{2}</script> means <em>practically-verifiable</em> we mean less efficiently than <em>efficiently-verifiable</em>, but still efficient enough to be practical for some applications, for example the author considers the time-lock puzzle based cost-function with its two modular exponentiations to fall into this category. Value <script type="math/tex">e=0</script> means <em>verifiable but impractical</em>, that the cost-function is verifiable but the verification function is impractically slow such that the existance of the cost-function serves only as a proof of concept to be improved upon for practical use.</p>

<p>And <script type="math/tex">\sigma</script> is a characterization of the standard deviaion, value <script type="math/tex">\sigma=0</script> means <em>fixed-cost</em>, <script type="math/tex">\sigma=\frac{1}{2}</script> means <em>bounded probabilistic cost</em> and <script type="math/tex">\sigma=1</script> means <em>unbounded probabilistic cost</em>. Note by <em>bounded probabilistic-cost</em> we mean usefully bounded—a bound in the work factor in excess of a work-factor that an otherwise functionally similar unbounded cost-function would only reach with negligible probability would not be useful.</p>

<p>And <script type="math/tex">i</script> denotes that the function is <em>interactive</em>, and <script type="math/tex">\bar{i}</script> that the cost-function is <em>non-interactive</em>.</p>

<p>And <script type="math/tex">a</script> denotes that that the cost-function is <em>publicly auditable</em>, <script type="math/tex">\bar{a}</script> denotes that the cost-function is not <em>publicly auditable</em>, which means in practice that it is only verifiable by the service using a private key material. Note by <em>public-auditability</em> we mean <em>efficiently</em> publicly-auditable, and would not consider repeating the work of the token minter as adequate efficiency to classify.</p>

<p>And <script type="math/tex">t</script> denotes that the server has a <em>trapdoor</em> in computing the cost-function, conversely <script type="math/tex">\bar{t}</script> denotes that server has no trapdoor in computing the cost-function.</p>

<p>And <script type="math/tex">p</script> denotes that the cost-function is parallelizable, <script type="math/tex">\bar{p}</script> denotes that the cost function is <em>non-parallizeable</em>.</p>

<p><img src="hashcash/comparison-chart.png" alt="comparison-chart.png" /></p>

<h4 id="open-problems">8.1 Open Problems</h4>
<ul>
  <li>existance of <em>efficiently-verifiable non-interactive fixed-cost</em> cost functions <script type="math/tex">(e=1,\sigma=0,\bar{i})</script> (and the related weaker problem: existance of same with <em>probabilistic bounded-cost</em> <script type="math/tex">(e=1,\sigma=\frac{1}{2},\bar{i})</script>)</li>
  <li>existance of <em>efficiently-verifiable non-interactive non-parallelizable</em> cost-functions <script type="math/tex">(e=1,\bar{i},\bar{p})</script> (and the related weaker problem: existance of same in interactive setting <script type="math/tex">(e=1,i,\bar{p})</script>)</li>
  <li>existance of <em>publicly-auditable non-interactive fixed-cost</em> cost-functions <script type="math/tex">(\sigma=0,\bar{i},a)</script> (and the related weaker problem: existance of same with <em>bounded probabilistic-cost</em> <script type="math/tex">(\sigma=\frac{1}{2},\bar{i},a)</script>)</li>
</ul>

        </div>

      </section>

      <footer>
  <social>
	<a href="http://facebook.com/danielsuo"><img src="/assets/img/facebook.png"></a>
	<a href="http://twitter.com/danielsuo"><img src="/assets/img/twitter.png"></a>
  <a href="http://www.linkedin.com/in/danielsuo"><img src="/assets/img/linkedin.png"></a>
  <a href="https://github.com/danielsuo"><img src="/assets/img/github.png"></a> 
  <a href="/feed.xml"><img src="/assets/img/rss.png"></a> 
</social>
  <br><br>
  <small>Complain <a href="mailto:dsuo@post.harvard.edu">here</a>.</small>
  <small><a href="/pubkey.txt">Securely</a>.</small>
</footer>
      
    </div>

    <script src='/assets/js/scale.fix.js'></script>
    <script type="text/javascript">
var gaJsHost = (('https:' == document.location.protocol) ? 'https://ssl.' : 'http://www.');
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
varpagetracker:_gat._getTracker(UA-37351701-1)
}


  </body>
</html>