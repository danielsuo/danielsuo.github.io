<!doctype html>
<html>

  <head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Daniel Suo | Scientific progress goes 'boink'</title>

<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/pygment_trac.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/assets/img/profile.jpg" />

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"> </script>












<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
</head>


  <body id=''>

    <div class='wrapper'>

      <header>
    <h1>Daniel Suo</h1>
    <p>Scientific progress goes 'boink'</p>


    <p>
      Ph.D. Candidate<br>
      Princeton University<br>
      Department of Computer Science
    </p>

    <ul>
    	<li><a href="/">home</a></li>
      <!-- <li><a href="https://blog.danielsuo.com">blog</a> -->
      <!-- <li><a href="/projects">projects</a></li> -->
      <li><a href="/notes">notes</a></li>
      <li><a href="https://github.com/danielsuo/cv/raw/master/cv.pdf">cv</a></li>
    </ul>

</header>

      <section>
        <nav class="breadcrumbs bootstrap hidden-sm-down" >
  <ol class="breadcrumb list-unstyled" vocab="http://schema.org/" typeof="BreadcrumbList">
    
    
      

      

      

      <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
          <a property="item" typeof="WebPage" href="/"><span property="name">home</span><meta property="position" content="1" /></a>
      </li>
    
      

      

      

      <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
          <a property="item" typeof="WebPage" href="/notes/"><span property="name">notes</span><meta property="position" content="2" /></a>
      </li>
    
      

      

      

      <li class="breadcrumb-item" property="itemListElement" typeof="ListItem">
          <a property="item" typeof="WebPage" href="/notes/reading/"><span property="name">reading</span><meta property="position" content="3" /></a>
      </li>
    
      

      

      
        <li class="breadcrumb-item" property="itemListElement" typeof="ListItem"><span property="name"></span><meta property="position" content="4" /></li>
        

  </ol>
</nav>


<!-- This is an example of CSS. Maybe you want to implement the css code into your main css file or modify it as you want -->
<style>
nav.breadcrumbs.bootstrap {
  /* from Twitter Bootstrap 4 */
  /* If you already use Twitter, you do not need these css lines above, cause they already in Twitter Bootstrap */
  /* Additions: image integration */
}
nav.breadcrumbs.bootstrap ol {
  margin-left: 0
}
nav.breadcrumbs.bootstrap .breadcrumb {
  font-size: 1rem;
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
  list-style: none;
  background-color: #f1f2ed;
  border-radius: 0.25rem;
}
nav.breadcrumbs.bootstrap .breadcrumb::after {
  content: "";
  display: table;
  clear: both;
}
nav.breadcrumbs.bootstrap .breadcrumb-item {
  float: left;
}
nav.breadcrumbs.bootstrap .breadcrumb-item + .breadcrumb-item::before {
  display: inline-block;
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #818a91;
  content: "/";
}
nav.breadcrumbs.bootstrap .breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: underline;
}
nav.breadcrumbs.bootstrap .breadcrumb-item + .breadcrumb-item:hover::before {
  text-decoration: none;
}
nav.breadcrumbs.bootstrap .breadcrumb-item-active {
  color: #818a91;
}

nav.breadcrumbs.bootstrap .breadcrumb a.breadcrumb-item:after {
  display: inline-block;
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  content: "/";
  text-decoration: none;
}
nav.breadcrumbs.bootstrap .breadcrumb .icon:after {
  display: inline-block;
  padding-right: 0.5rem;
  padding-left: 0.5rem;
  color: #818a91;
  content: "/";
}
nav.breadcrumbs.bootstrap .breadcrumb .icon {
  display: inline-block;
}
nav.breadcrumbs.bootstrap .breadcrumb .icon svg {
  height: 0.7rem;
  width: 0.7rem;
}
</style>


        <div id='container'>
          <h1 id="bigtable-a-distributed-storage-system-for-structured-data">Bigtable: A Distributed Storage System for Structured Data</h1>
<p><a href="http://xpgc.vicp.net/course/svt/TechDoc/storagepaper/bigtable-osdi06.pdf">link</a>
<a href="http://courses.cs.vt.edu/cs5204/fall11-kafura/Student-Presentations/Bigtable-Notes.pdf">notes</a></p>

<p>NOTE: taken from notes above.</p>

<p>This is a summary of the paper “Bigtable: A Distributed Storage System for Structured Data”. References
are shorthanded as (x.y) where x is the page number and y is the paragraph on that page.</p>

<h2 id="background">Background</h2>

<p>Google’s Bigtable is a datastructure similar to, but not to be confused with a relational database (1.3). It
is meant to be general enough to handle a wide variety of uses, but the primary drivers are extremely
large data sets and high performance for the client (1.2). Currently more than 60 products use Bigtable
and several hundred terabytes in practice (although petabyte size is theoretically possible) (1.2).</p>

<h2 id="data-structure">Data Structure</h2>

<p>The basic unit of the table is the untyped string which at the lowest level are stored in sorted string
tables or SSTables which are small enough to fit in RAM (3.9, 4.1). The SSTable is an immutable map of
type (string key)  string data. Bigtable is exposed to the user as a three-dimensional map of type
(string row, string col, int64 time)string data (1.3, 1.4). As a result of the underlying SSTable structure
Bigtable is sorted lexicographically along row, col and time (2.3). The row and col keys can be 64KB in
size, although that’s not usually necessary (2.2).</p>

<p>The multi-dimensional map is divided into row ranges (i.e. A-D, E-F,G-P,Q-Z) referred to as a tablet (2.3,
4.8). Each tablet can be between 100MB and 200MB (4.8). As data is added to the tablet range the
tablet expands and eventually splits into two distinct tablets (i.e. A-D  A-B and C-D) (4.8).</p>

<p>The multi-dimensional map is divided into column families based on user defined groups (2.4). The
column family is created first as a data category (2.4). Each column is added to a column family and
cannot exist on its own (2.4). Typically there are relatively few column families, but many more columns
(2.4). The column keys are in the form Family_name:Column_name (2.5). Granularity at the column
family level is used to control access, disk/memory accounting and garbage handling (2.6, 3.2).</p>

<p>The multi-dimensional map automatically assigns “real” timestamps based on when data was entered
(2.7). If a real timestamp is used, the possibility of collision is guaranteed not to occur (3.1). The client
application can explicitly assign timestamps based on some internal versioning system (2.7). Version
numbers are used in garbage collection either to maintain a maximum number of versions or maintain
versions “younger” than an arbitrary age (3.2).</p>

<h2 id="bigtable-api">Bigtable API</h2>
<p>The API has several means of controlling data access to improve performance and simplify coding. Readmodify-write
operations can be performed atomically on a single row regardless of the number columns
updated (2.2, 3.6, Figure 2). Reads can be performed in sections based on a row range (3.5). Typically
similar or nearly adjacent rows are on the same tablet and therefore can be accessed with one network
call (2.3). Records can be fetched by specific rows, columns or versions based on various limiting factors
such as matching regular expressions or a range of versions (3.5, Figure 3). New data can be written and
old data deleted (3.5). Direct iteration over the fetched data can be used just as on any other collection
library (3.5, 4.1). Client applications can also use the scripts written in Sawzall to instruct server-side
data processing prior to the network fetch but specifically excluding any write operation (3.6). The API
also allows map reduce function to work on Bigtable and produce Bigtable in a closed algebra (3.7).</p>

<p>Client applications can improve performance in various ways beyond those imposed by the API. As
noted above they can define the access control rights, disk/memory storage, versioning schemes and
garbage handling functions for a column family (2.6, 3.2). The client application can also use their own
“cleverness” in serializing the data and creating the row and column names (1.3). The client application
can add/delete tables and column families as necessary (3.4). By analyzing the application domain, these
properties may be used in conjunction with the abilities of the API to improve performance beyond that
of a generic Bigtable.</p>

<h2 id="server-address-discovery">Server Address Discovery</h2>
<p>The Bigtable servers are discovered through a B-Tree with three levels (4.9). A bootstrap pointer is used
to identify the location of the root tablet (4.9). The root tablet is unique in that it is never split (4.9). The
root tablet points to a set of tablets which point to all the other tablets in the Bigtable (4.9). The root
tablet and the set it points to are known collectively as the metadata table (4.9). The metadata table
stores table name and end-row key values along with the address (4.10). Even with a moderate tablet
size the resulting address space can be very large (5.1).</p>

<p>The system requires 3 network reads to discover any address (5.2). Although this system works for
discovery, it is not necessary to always perform so many as addresses are aggressively cached and kept
in larger-than necessary groups (5.2). Occasionally a tablet will have been moved so a search at the next
highest level of the B-tree will be necessary (5.2). In the worst case scenario (all tables in the branch
have been moved) six network reads are necessary (5.2).</p>

<h2 id="server-failover-and-recovery">Server Failover and Recovery</h2>
<p>The table exist on a variety of servers, necessitating a management scheme encompassing failover and
recovery (3.8). Availability statistics show an average of .0047% down time (4.3). A mainstay of the
system’s reliability is the Chubby file system which is used throughout (4.3). Chubby creates 5 replicas of
each file to avoid loss during failover (4.2). One copy is the master and the rest are kept current using
the Paxos algorithm (4.2). Chubby’s use of files and folders with individual locks that must be maintained
within a session (4.2). If a server, including the master, loses connectivity for too long its session will
automatically expire and the lock will be lost (4.2, 5.6). If the master server loses its lock it will
automatically kill itself.</p>

<p>The underlying Chubby file system is used in many ways to coordinate and increase availability. One
server is uses as the master for the system (4.3). The Chubby system stores the bootstrap pointer to the
table’s B-Tree (4.3). It maintains a tablet directory with individual files for each tablet and particularly
the unique master file (4.3, 5.7). This directory is used for tablet discovery, to determine the death of a
server and to coordinate tablet splits/mergers (4.3).</p>

<p>The master server contains no tablets and is not used to locating the tablet servers (4.4, 4.7, 5.2). It’s
sole purpose is to assign tablets to the various tablet servers and balance the load between them (4.5).
This also leads to related duties such as adding/removing tablet servers, maintaining a list of unassigned
tablets, garbage collection, creation of new tables and merging of tablets (4.5, 5.8). Only one server has
a “live” copy of a tablet at a time (5.4). The live tablet status is determined by ownership of a Chubby file
lock corresponding to the tablet (5.5).</p>

<p>The master server periodically attempts to acquire the existing locks (5.7). If the master identifies an
unused lock the tablet is seen as unassigned and the master will reassign it to another tablet (5.5, 5.6).
The original file is destroyed to prevent the former tablet server from reacquiring it (5.6). If the master
itself fails a new master is assigned and it will start by checking the locks again (5.7). The polled locks are
used to identify live servers, which are then polled to determine the set of live tablets (5.7). If the root
tablet is not identified in this step it is immediately listed as unassigned and assigned to another server
(5.8). Finally a search through the metadata tablets will indicate the complimentary set of unassigned
tablets (5.7).</p>

<p>There are many tablet servers, each keeping 10 to 1000 tablets (4.4, 4.6). The server handles all
read/write requests on its own tablets (4.6, 4.7). When any one tablet gets too large the server will split
the tablet (4.6, 5.8). Upon a split, the tablet server creates a new file in the Chubby system and notifies
the master (5.8). Even if the message is lost or if the master server fails, the new file itself will prompt
the same division (6.1).</p>

<h2 id="read-write-and-the-google-file-system">Read, Write and the Google File System</h2>
<p>Changes to the data are initially committed to the a log on the GFS (6.2). The original data is maintained
in SSTables also on the GFS (6.2). The live tablet server will maintain a “memtable” in RAM which
contains a record of all the logged commitments (6.2). The union of the memtable and SSTables is the
true state of memory (6.2). Write operations result in updates in both the commit log and memtable,
including deletions (6.3, 6.7). Read operations read simultaneously and sequentially from memtable and
SSTable with an automatic merge as they are both sorted (6.2, 6.4). If the tablet must be recovered the
memtable and SSTables are read and merged (6.2). Deletions in any subset will result in suppressing
other data from the whole (6.7).
Periodically the whole set of data is collected. This comes in three flavors. Minor compactions merge the
memtable and SSTable into a new SSTable (6.5). This is prompted with the memtable is too large and
the result is free server RAM in trade for more GFS space (6.5). Eventually this behavior will overwhelm
the system (6.6). An unnamed middle compaction merges memtable and more than one SSTable to free
up GFS space (6.6). Major compactions merge the whole set into one SSTable (6.7). The resulting
SSTable contains no deletions as they have been used to suppress prior data (6.7). Major compactions
have additional benefits of permanently removing old data, reducing the total amount of memory and
permanently finalizing the data into GFS (6.7).</p>

        </div>

      </section>

      <footer>
  <!-- <img src='/assets/img/bronze-22BC.png' class='nand'> -->
  <!-- <br> -->
  <!--email_off-->
    <small>Complain <a href="mailto:dsuo@cs.princeton.edu" target="_blank">here</a>.</small>
  <!--/email_off-->
  <small><a href="/pubkey.txt" target="_blank">Securely</a>.</small>

  <br>

  <social>
  <ul>
    <li><a href="mailto:dsuo@cs.princeton.edu" target="_blank"><i class="fa fa-envelope fa"></i></a></li>
    <!--/email_off-->
    <li><a href="https://github.com/danielsuo" target="_blank"><i class="fa fa-github fa"></i></a></li> 
    <li><a href="http://www.linkedin.com/in/danielsuo" target="_blank"><i class="fa fa-linkedin fa"></i></a></li>
    <li><a href="http://twitter.com/danielsuo" target="_blank"><i class="fa fa-twitter fa"></i></a></li>
    <li><a href="/feed.xml" target="_blank"><i class="fa fa-rss fa"></i></a></li> 
  </ul>
  </social>
</footer>


    </div>

    <script src='/assets/js/scale.fix.js'></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37351701-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>
